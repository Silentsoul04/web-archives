From: Andrew Cooper <andrew.cooper3@citrix.com>
Subject: x86/pv: Improve pv_cpuid()'s API

pv_cpuid()'s API is awkward to use.  There are already two callers jumping
through hoops to use it, and a third is on its way.

Change the API to take each parameter individually (like its counterpart,
hvm_cpuid(), already does), and introduce a new pv_cpuid_regs() wrapper
implementing the old API.

No functional change.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>

diff --git a/xen/arch/x86/hvm/vmx/vmx.c b/xen/arch/x86/hvm/vmx/vmx.c
index 82e3c2c..59395dd 100644
--- a/xen/arch/x86/hvm/vmx/vmx.c
+++ b/xen/arch/x86/hvm/vmx/vmx.c
@@ -3698,7 +3698,7 @@ void vmx_vmexit_handler(struct cpu_user_regs *regs)
         break;
     }
     case EXIT_REASON_CPUID:
-        is_pvh_vcpu(v) ? pv_cpuid(regs) : vmx_do_cpuid(regs);
+        is_pvh_vcpu(v) ? pv_cpuid_regs(regs) : vmx_do_cpuid(regs);
         update_guest_eip(); /* Safe: CPUID */
         break;
     case EXIT_REASON_HLT:
diff --git a/xen/arch/x86/traps.c b/xen/arch/x86/traps.c
index 139737b..c001f93 100644
--- a/xen/arch/x86/traps.c
+++ b/xen/arch/x86/traps.c
@@ -924,17 +924,14 @@ static void _domain_cpuid(struct domain *currd,
         cpuid_count(leaf, subleaf, eax, ebx, ecx, edx);
 }
 
-void pv_cpuid(struct cpu_user_regs *regs)
+void pv_cpuid(uint32_t leaf, uint32_t subleaf,
+              uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)
 {
-    uint32_t leaf, subleaf, a, b, c, d;
+    uint32_t a, b, c, d;
+    const struct cpu_user_regs *regs = guest_cpu_user_regs();
     struct vcpu *curr = current;
     struct domain *currd = curr->domain;
 
-    leaf = a = regs->eax;
-    b = regs->ebx;
-    subleaf = c = regs->ecx;
-    d = regs->edx;
-
     if ( cpuid_hypervisor_leaves(leaf, subleaf, &a, &b, &c, &d) )
         goto out;
 
@@ -1200,17 +1197,21 @@ void pv_cpuid(struct cpu_user_regs *regs)
     case 0x8000001e: /* Extended topology reporting */
     unsupported:
         a = b = c = d = 0;
-        break;
+        goto out;
     }
 
- out:
     /* VPMU may decide to modify some of the leaves */
     vpmu_do_cpuid(leaf, &a, &b, &c, &d);
 
-    regs->eax = a;
-    regs->ebx = b;
-    regs->ecx = c;
-    regs->edx = d;
+ out:
+    if ( eax )
+        *eax = a;
+    if ( ebx )
+        *ebx = b;
+    if ( ecx )
+        *ecx = c;
+    if ( edx )
+        *edx = d;
 }
 
 static int emulate_invalid_rdtscp(struct cpu_user_regs *regs)
@@ -1260,7 +1261,7 @@ static int emulate_forced_invalid_op(struct cpu_user_regs *regs)
         return 0;
     eip += sizeof(instr);
 
-    pv_cpuid(regs);
+    pv_cpuid_regs(regs);
 
     instruction_done(regs, eip, 0);
 
@@ -3135,7 +3136,7 @@ static int emulate_privileged_op(struct cpu_user_regs *regs)
         break;
 
     case 0xa2: /* CPUID */
-        pv_cpuid(regs);
+        pv_cpuid_regs(regs);
         break;
 
     default:
diff --git a/xen/include/asm-x86/processor.h b/xen/include/asm-x86/processor.h
index 14bed92..6a35b89 100644
--- a/xen/include/asm-x86/processor.h
+++ b/xen/include/asm-x86/processor.h
@@ -649,7 +649,14 @@ enum get_cpu_vendor {
 };
 
 int get_cpu_vendor(const char vendor_id[], enum get_cpu_vendor);
-void pv_cpuid(struct cpu_user_regs *regs);
+void pv_cpuid(uint32_t leaf, uint32_t subleaf,
+              uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx);
+
+static inline void pv_cpuid_regs(struct cpu_user_regs *regs)
+{
+    pv_cpuid(regs->_eax, regs->_ecx,
+             &regs->_eax, &regs->_ebx, &regs->_ecx, &regs->_edx);
+}
 
 #endif /* !__ASSEMBLY__ */
 
